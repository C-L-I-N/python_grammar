# 🎓 Day 6：元组 (Tuples) — 不可变的序列之美

同学们好！今天我们来学习Python中一个非常重要的数据结构——**元组（Tuple）**。

---

## 📖 什么是元组？

> **元组是一个有序且不可变（immutable）的数据集合，使用圆括号 `()` 表示。**

这是元组与列表最核心的区别：**一旦创建，元组的值就不能被修改**。

```python
# 列表可以修改
my_list = [1, 2, 3]
my_list[0] = 100  # ✅ 没问题

# 元组不可修改
my_tuple = (1, 2, 3)
my_tuple[0] = 100  # ❌ TypeError: 'tuple' object does not support item assignment
```

### 元组的方法（只有两个！）

由于不可变性，元组只有极少的方法：

| 方法 | 说明 |
|------|------|
| `count()` | 统计某个元素出现的次数 |
| `index()` | 查找某个元素的索引位置 |
| `+` 运算符 | 连接两个或多个元组 |

---

## 🔨 创建元组

### 1. 空元组

```python
# 方式一：直接使用圆括号
empty_tuple = ()

# 方式二：使用 tuple() 构造函数
empty_tuple = tuple()
```

### 2. 带初始值的元组

```python
fruits = ('banana', 'orange', 'mango', 'lemon')
numbers = (1, 2, 3, 4, 5)
mixed = ('Python', 3.11, True, [1, 2, 3])  # 可以包含不同类型
```

### ⚠️ 特别注意：单元素元组

```python
# 错误写法 - 这不是元组，是字符串！
not_tuple = ('hello')
print(type(not_tuple))  # <class 'str'>

# 正确写法 - 必须加逗号
single_tuple = ('hello',)
print(type(single_tuple))  # <class 'tuple'>
```

---

## 📏 获取元组长度

使用 `len()` 函数：

```python
fruits = ('banana', 'orange', 'mango', 'lemon')
print(len(fruits))  # 4
```

---

## 🔍 访问元组元素

### 正向索引（从0开始）

```
索引:     0         1         2        3
元组: ('banana', 'orange', 'mango', 'lemon')
```

```python
fruits = ('banana', 'orange', 'mango', 'lemon')
print(fruits[0])  # banana
print(fruits[1])  # orange
print(fruits[3])  # lemon
```

### 负向索引（从末尾开始）

```
索引:    -4        -3        -2       -1
元组: ('banana', 'orange', 'mango', 'lemon')
```

```python
fruits = ('banana', 'orange', 'mango', 'lemon')
print(fruits[-1])  # lemon（最后一个）
print(fruits[-4])  # banana（第一个）
```

---

## ✂️ 元组切片

切片语法：`tuple[start:end:step]`

```python
fruits = ('banana', 'orange', 'mango', 'lemon')

# 获取全部元素
print(fruits[0:4])   # ('banana', 'orange', 'mango', 'lemon')
print(fruits[:])     # ('banana', 'orange', 'mango', 'lemon')

# 获取部分元素
print(fruits[1:3])   # ('orange', 'mango') - 不包含索引3
print(fruits[1:])    # ('orange', 'mango', 'lemon') - 从索引1到末尾

# 负向切片
print(fruits[-3:-1]) # ('orange', 'mango') - 不包含-1位置
print(fruits[-3:])   # ('orange', 'mango', 'lemon')
```

---

## 🔄 元组与列表的转换

由于元组不可变，如果需要修改，必须先转为列表：

```python
fruits = ('banana', 'orange', 'mango', 'lemon')

# 转换为列表进行修改
fruits_list = list(fruits)
fruits_list[0] = 'apple'
print(fruits_list)  # ['apple', 'orange', 'mango', 'lemon']

# 再转回元组
fruits = tuple(fruits_list)
print(fruits)  # ('apple', 'orange', 'mango', 'lemon')
```

---

## 🔎 检查元素是否存在

使用 `in` 关键字：

```python
fruits = ('banana', 'orange', 'mango', 'lemon')

print('orange' in fruits)  # True
print('apple' in fruits)   # False
print('apple' not in fruits)  # True
```

---

## ➕ 连接元组

使用 `+` 运算符：

```python
fruits = ('banana', 'orange', 'mango', 'lemon')
vegetables = ('Tomato', 'Potato', 'Cabbage', 'Onion')

# 合并两个元组
food = fruits + vegetables
print(food)
# ('banana', 'orange', 'mango', 'lemon', 'Tomato', 'Potato', 'Cabbage', 'Onion')
```

---

## 🗑️ 删除元组

无法删除元组中的单个元素，但可以删除整个元组：

```python
fruits = ('banana', 'orange', 'mango', 'lemon')
del fruits  # 完全删除元组

print(fruits)  # NameError: name 'fruits' is not defined
```

---

## 🎁 元组解包（Tuple Unpacking）

这是元组的一个强大特性！

```python
# 基本解包
fruits = ('apple', 'banana', 'cherry')
a, b, c = fruits
print(a)  # apple
print(b)  # banana
print(c)  # cherry

# 使用 * 收集剩余元素
numbers = (1, 2, 3, 4, 5)
first, *middle, last = numbers
print(first)   # 1
print(middle)  # [2, 3, 4]
print(last)    # 5
```

---

## 🤔 何时使用元组而非列表？

| 使用场景 | 推荐类型 |
|----------|----------|
| 数据需要修改 | 列表 `list` |
| 数据不应被修改（如坐标、RGB颜色） | 元组 `tuple` |
| 作为字典的键 | 元组 `tuple`（列表不可哈希） |
| 函数返回多个值 | 元组 `tuple` |
| 需要更快的遍历速度 | 元组 `tuple`（略快于列表） |

---

## 💻 课后练习

### Level 1（基础）
1. 创建一个空元组
2. 创建一个包含你兄弟姐妹名字的元组
3. 合并两个元组并赋值给新变量
4. 统计合并后元组的长度
5. 将元组转为列表，添加父母名字，再转回元组

### Level 2（进阶）
1. 对 `family_members` 元组进行解包
2. 创建水果、蔬菜、肉类三个元组，合并为 `food_stuff_tp`
3. 将元组转为列表
4. 切片获取中间元素
5. 检查某元素是否存在于元组中：
   ```python
   nordic_countries = ('Denmark', 'Finland', 'Iceland', 'Norway', 'Sweden')
   # 检查 'Estonia' 是否是北欧国家？
   # 检查 'Iceland' 是否是北欧国家？
   ```

---

> 🌟 **教授寄语**：元组虽然简单，但其不可变性在编程中有着重要意义——它保证了数据的完整性和安全性。掌握好列表和元组的选择，是Python进阶的重要一步！

**下一课预告：Day 7 — 集合 (Sets)**

